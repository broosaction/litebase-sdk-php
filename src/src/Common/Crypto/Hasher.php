<?php
/**
 * Created by Bruce Mubangwa on 08 /Jun, 2021 @ 9:42
 */

namespace Litebase\Common\Crypto;


class Hasher
{

    /** @var array Options passed to password_hash and password_needs_rehash */
    private $options = [];
    /** @var string Salt used for legacy passwords */
    private $legacySalt = null;


    /**
     * Hasher constructor.
     * Broos Action Aria Framework core Hash functions,
     * to be used in all SDKs
     * @link https://broos.link
     */
    public function __construct($salt = '') {

        if (\defined('PASSWORD_ARGON2I')) {
            // password_hash fails, when the minimum values are undershot.
            // In this case, ignore and revert to default

            /**
             * The allowed maximum memory in KiB to be used by the algorithm for computing a
             * hash. The smallest possible value is 8. Values that undershoot the minimum
             * will be ignored in favor of the default.
             */
                $this->options['memory_cost'] = PASSWORD_ARGON2_DEFAULT_MEMORY_COST;

            /**
             * The allowed maximum time in seconds that can be used by the algorithm for
             * computing a hash. The value must be an integer, and the minimum value is 1.
             * Values that undershoot the minimum will be ignored in favor of the default.
             */
                $this->options['time_cost'] = PASSWORD_ARGON2_DEFAULT_TIME_COST;

            /**
             * The allowed number of CPU threads that can be used by the algorithm for
             * computing a hash. The value must be an integer, and the minimum value is 1.
             * Rationally it does not help to provide a number higher than the available
             * threads on the machine. Values that undershoot the minimum will be ignored
             * in favor of the default.
             */
                $this->options['threads'] = PASSWORD_ARGON2_DEFAULT_THREADS;
        }

            /**
             * The hashing cost used by hashes generated by Broos Action Systems
             * Using a higher value requires more time and CPU power to calculate the hashes
             */
            $this->options['cost'] = 10;

            if($salt !== ''){

                $this->options['salt'] = $salt;

            }

    }

    /**
     * Hashes a message using PHP's `password_hash` functionality.
     * Please note that the size of the returned string is not guaranteed
     * and can be up to 255 characters.
     *
     * @param string $message Message to generate hash from
     * @return string Hash of the message with appended version parameter
     */
    public function hash(string $message): string {

        $alg = $this->getPrefferedAlgorithm();

        if (\defined('PASSWORD_ARGON2I') && $alg === PASSWORD_ARGON2I) {
            return 2 . '|' . password_hash($message, PASSWORD_ARGON2I, $this->options);
        }

        return 1 . '|' . password_hash($message, PASSWORD_BCRYPT, $this->options);
    }

    /**
     * Get the version and hash from a prefixedHash
     * @param string $prefixedHash
     * @return null|array Null if the hash is not prefixed, otherwise array('version' => 1, 'hash' => 'foo')
     */
    protected function splitHash(string $prefixedHash) {
        $explodedString = explode('|', $prefixedHash, 2);
        if(\count($explodedString) === 2) {
            if((int)$explodedString[0] > 0) {
                return ['version' => (int)$explodedString[0], 'hash' => $explodedString[1]];
            }
        }

        return null;
    }

    /**
     * Verify legacy hashes
     * @param string $message Message to verify
     * @param string $hash Assumed hash of the message
     * @param null|string &$newHash Reference will contain the updated hash
     * @return bool Whether $hash is a valid hash of $message
     */
    protected function legacyHashVerify($message, $hash, &$newHash = null): bool {
        if(empty($this->legacySalt)) {
            $this->legacySalt = 'd3c944a9af095aa08f';
        }

        // Verify whether it matches a legacy PHPass or SHA1 string
        $hashLength = \strlen($hash);
        if(($hashLength === 60 && password_verify($message.$this->legacySalt, $hash)) ||
            ($hashLength === 40 && hash_equals($hash, sha1($message)))) {
            $newHash = $this->hash($message);
            return true;
        }

        return false;
    }

    /**
     * Verify V1 (blowfish) hashes
     * @param string $message Message to verify
     * @param string $hash Assumed hash of the message
     * @param null|string &$newHash Reference will contain the updated hash if necessary. Update the existing hash with this one.
     * @return bool Whether $hash is a valid hash of $message
     */
    protected function verifyHashV1(string $message, string $hash, &$newHash = null): bool {
        if(password_verify($message, $hash)) {
            if ($this->needsRehash($hash)) {
                $newHash = $this->hash($message);
            }
            return true;
        }

        return false;
    }

    /**
     * Verify V2 (argon2i) hashes
     * @param string $message Message to verify
     * @param string $hash Assumed hash of the message
     * @param null|string &$newHash Reference will contain the updated hash if necessary. Update the existing hash with this one.
     * @return bool Whether $hash is a valid hash of $message
     */
    protected function verifyHashV2(string $message, string $hash, &$newHash = null) : bool {
        if(password_verify($message, $hash)) {
            if($this->needsRehash($hash)) {
                $newHash = $this->hash($message);
            }
            return true;
        }

        return false;
    }

    /**
     * @param string $message Message to verify
     * @param string $hash Assumed hash of the message
     * @param null|string &$newHash Reference will contain the updated hash if necessary. Update the existing hash with this one.
     * @return bool Whether $hash is a valid hash of $message
     */
    public function verify(string $message, string $hash, &$newHash = null): bool {
        $splittedHash = $this->splitHash($hash);

        if(isset($splittedHash['version'])) {
            switch ($splittedHash['version']) {
                case 2:
                    return $this->verifyHashV2($message, $splittedHash['hash'], $newHash);
                case 1:
                    return $this->verifyHashV1($message, $splittedHash['hash'], $newHash);
            }
        } else {
            return $this->legacyHashVerify($message, $hash, $newHash);
        }

        return false;
    }

    private function needsRehash(string $hash): bool {
        $algorithm = $this->getPrefferedAlgorithm();

        return password_needs_rehash($hash, $algorithm, $this->options);
    }

    private function getPrefferedAlgorithm() {
        $default = PASSWORD_BCRYPT;
        if (\defined('PASSWORD_ARGON2I')) {
            $default = PASSWORD_ARGON2I;
        }

        return $default;
    }

}